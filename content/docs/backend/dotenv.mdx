## ğŸ“¦ Advanced `.env` Configuration

By default, [`dotenv`](https://www.npmjs.com/package/dotenv) loads `.env` from the project root.

### âœ… You can customize:

| Feature                | Example/Benefit                              |
| ---------------------- | -------------------------------------------- |
| Custom file path       | Load `.env.staging`, `.env.local`, etc.      |
| Override loading logic | Load by `NODE_ENV`, CI config, or CLI flags  |
| Multiple `.env` files  | Separate config for dev, test, staging, prod |

---

## ğŸ“ Recommended Folder Structure

```
project-root/
â”‚
â”œâ”€â”€ src/
â”‚   â””â”€â”€ config/
â”‚       â””â”€â”€ env.ts          # central validated config
â”‚
â”œâ”€â”€ .env                   # local dev
â”œâ”€â”€ .env.production        # production server
â”œâ”€â”€ .env.staging           # staging environment
â”œâ”€â”€ .env.test              # test runner config
â”œâ”€â”€ .env.example           # shared reference (no secrets)
```

---

## ğŸ”§ Custom dotenv Configuration (Advanced)

### 1. Load custom file based on `NODE_ENV`

```ts
import path from 'path';
import dotenv from 'dotenv';

// Resolve correct file
const envFile = `.env.${process.env.NODE_ENV ?? 'development'}`;

dotenv.config({ path: path.resolve(process.cwd(), envFile) });
```

> âœ… Now `NODE_ENV=production` loads `.env.production` automatically.

---

### 2. Use `dotenv-flow` (Multi-stage override)

```bash
npm install dotenv-flow
```

```ts
import dotenvFlow from 'dotenv-flow';

dotenvFlow.config({
  path: path.resolve(process.cwd()), // custom base folder
  node_env: process.env.NODE_ENV, // e.g., development, test
});
```

> âœ… This loads `.env`, then `.env.local`, and finally `.env.development.local`, merging them in order.

---

### 3. Manual file override (CLI or Docker)

You can override dotenv completely:

```bash
dotenv -e .env.staging -- node dist/app.js
```

Or in Docker:

```Dockerfile
ENV DOTENV_CONFIG_PATH=./env/.env.production
```

---

## ğŸ§ª Validation After Custom Load

Once `.env` is loaded, use `zod` to validate it as before:

```ts
const envSchema = z.object({
  PORT: z.string().transform(Number),
  NODE_ENV: z.enum(['development', 'production', 'test', 'staging']),
  JWT_SECRET: z.string().min(16),
});

const parsed = envSchema.safeParse(process.env);
if (!parsed.success) {
  console.error('âŒ Invalid environment variables:', parsed.error.format());
  process.exit(1);
}
```

---

## ğŸš¨ Common Mistakes to Avoid

| Mistake                          | Why it's bad                       |
| -------------------------------- | ---------------------------------- |
| Hardcoding fallback secrets      | Prevents secure config enforcement |
| Committing `.env` accidentally   | Risks leaking secrets              |
| Skipping validation              | Can crash app in production        |
| Modifying `process.env` directly | Makes debugging and testing harder |

---

## âœ… Best Practices Summary

- âœ… Use `dotenv` or `dotenv-flow` for layered envs
- âœ… Validate with `zod` on startup
- âœ… Create `.env.example` for shared config contracts
- âœ… Load files by environment (`.env.development`, `.env.test`)
- âœ… Document required keys and types centrally (`env.ts`)
